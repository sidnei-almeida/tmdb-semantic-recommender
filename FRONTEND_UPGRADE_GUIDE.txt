================================================================================
                    FRONTEND UPGRADE GUIDE - NEW API ARCHITECTURE
================================================================================

IMPORTANT: A API agora funciona como um "Motor de Busca" (Retrieval Engine).
O re-ranking híbrido é feito no FRONT-END, não na API!

================================================================================
                           ARQUITETURA NOVA
================================================================================

FLUXO COMPLETO:

1. Usuário busca um filme no front-end
   ↓
2. Front-end busca dados do filme no TMDB
   ↓
3. Front-end envia tmdb_id (e dados completos se necessário) para a API
   ↓
4. API retorna Top 50 filmes similares (sem re-ranking)
   ↓
5. Front-end busca dados completos de todos os 50 filmes no TMDB
   ↓
6. Front-end faz re-ranking híbrido usando gêneros
   ↓
7. Front-end exibe os resultados finais ordenados

================================================================================
                        O QUE MUDOU NA API
================================================================================

ANTES (API antiga):
- Enviava: { synopsis, genre?, year?, title? }
- Retornava: { query, recommendations: [...], count }
- API fazia re-ranking

AGORA (API nova):
- Envia: { tmdb_id, top_k?, title?, overview?, genres?, ... }
- Retorna: Lista direta de filmes [ { tmdb_id, title, year, poster_path, genres_list }, ... ]
- API NÃO faz re-ranking (apenas busca/retrieval)
- Front-end faz re-ranking híbrido

================================================================================
                    WARM START vs COLD START
================================================================================

WARM START (Filme já existe no banco - 62K filmes):
------------------------------------------
Se o tmdb_id existe no movies_map da API, use apenas:

{
  "tmdb_id": 550,
  "top_k": 50
}

A API usa o embedding pré-computado (mais rápido).

COLD START (Filme novo não está no banco):
------------------------------------------
Se o tmdb_id NÃO existe, envie todos os dados:

{
  "tmdb_id": 99999,
  "top_k": 50,
  "title": "Frankenstein 2025",
  "overview": "A scientist in the future...",
  "genres": ["Science Fiction", "Horror"],
  "directors": ["Some Director"],
  "studios": ["Some Studio"],
  "countries": ["USA"],
  "year": 2025,
  "keywords": ["monster", "future"]
}

A API gera embedding on-the-fly usando a "sopa de metadados".

================================================================================
                    FORMATO DE RESPOSTA DA API
================================================================================

A API retorna uma LISTA direta (não um objeto):

[
  {
    "tmdb_id": 550,
    "title": "Fight Club",
    "year": "1999",
    "poster_path": "/pB8BM7pdSp6B6Ih7QZ4DrQ3PmJK.jpg",
    "genres_list": ["Drama"]
  },
  {
    "tmdb_id": 680,
    "title": "Pulp Fiction",
    "year": "1994",
    "poster_path": "/d5iIlFn5s0ImszYzBPb8JPIfbXD.jpg",
    "genres_list": ["Thriller", "Crime"]
  }
  // ... até 50 resultados
]

================================================================================
                    IMPLEMENTAÇÃO COMPLETA
================================================================================

STEP 1: TypeScript Interfaces
--------------------------------------

interface RecommendationRequest {
  tmdb_id: number;
  top_k?: number;  // Default: 50
  
  // Cold Start fields (só necessário se tmdb_id não estiver no banco)
  title?: string;
  overview?: string;
  genres?: string[];
  directors?: string[];
  studios?: string[];
  countries?: string[];
  year?: number;
  keywords?: string[];
}

interface MovieRecommendation {
  tmdb_id: number;
  title: string;
  year: string;
  poster_path: string | null;
  genres_list: string[];
}

interface TMDBMovie {
  id: number;
  title: string;
  overview: string;
  release_date: string;
  poster_path: string | null;
  genres: Array<{ id: number; name: string }>;
  // ... outros campos do TMDB
}

interface ReRankedMovie extends MovieRecommendation {
  bert_score: number;      // Pontuação do BERT (da API)
  genre_score: number;      // Pontuação de gênero (calculada no front)
  final_score: number;      // Pontuação final (0.7 * BERT + 0.3 * Gênero)
  tmdb_data?: TMDBMovie;    // Dados completos do TMDB
}

================================================================================

STEP 2: Função para Buscar Filme no TMDB
------------------------------------------

const TMDB_API_KEY = 'your-tmdb-api-key';
const TMDB_BASE_URL = 'https://api.themoviedb.org/3';

async function getMovieFromTMDB(tmdbId: number): Promise<TMDBMovie> {
  const response = await fetch(
    `${TMDB_BASE_URL}/movie/${tmdbId}?api_key=${TMDB_API_KEY}`
  );
  
  if (!response.ok) {
    throw new Error(`TMDB API error: ${response.status}`);
  }
  
  return await response.json();
}

================================================================================

STEP 3: Função para Chamar a API de Recomendação
-------------------------------------------------

const RECOMMENDATION_API_URL = 'https://tmdb-semantic-recommender.onrender.com/api/v1/recommend';

async function getRecommendations(
  tmdbId: number,
  tmdbMovieData?: TMDBMovie
): Promise<MovieRecommendation[]> {
  // Preparar payload (Warm Start ou Cold Start)
  const payload: RecommendationRequest = {
    tmdb_id: tmdbId,
    top_k: 50,
  };
  
  // Se temos dados do TMDB, podemos tentar Cold Start (caso o filme não esteja no banco)
  // Na prática, você pode sempre tentar Warm Start primeiro e só usar Cold Start se der erro
  if (tmdbMovieData) {
    // Extrair dados para Cold Start (caso necessário)
    payload.title = tmdbMovieData.title;
    payload.overview = tmdbMovieData.overview;
    payload.genres = tmdbMovieData.genres.map(g => g.name);
    payload.year = parseInt(tmdbMovieData.release_date.split('-')[0]);
    
    // Extrair outros campos se disponíveis
    // payload.directors = ... (se você tiver essa info)
    // payload.studios = ... (se você tiver essa info)
    // payload.countries = ... (se você tiver essa info)
    // payload.keywords = ... (se você tiver essa info)
  }
  
  const response = await fetch(RECOMMENDATION_API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  
  if (!response.ok) {
    throw new Error(`Recommendation API error: ${response.status}`);
  }
  
  // A API retorna uma lista direta
  return await response.json();
}

================================================================================

STEP 4: Função para Calcular Pontuação de Gênero
--------------------------------------------------

/**
 * Calcula a pontuação de gênero usando interseção Jaccard.
 * Fórmula: |Gêneros em Comum| / |Gêneros da Query|
 */
function calculateGenreScore(
  queryGenres: string[],
  candidateGenres: string[]
): number {
  if (queryGenres.length === 0) return 0;
  if (candidateGenres.length === 0) return 0;
  
  // Normalizar gêneros (lowercase, sem espaços extras)
  const normalize = (genres: string[]) =>
    genres.map(g => g.trim().toLowerCase()).filter(g => g.length > 0);
  
  const querySet = new Set(normalize(queryGenres));
  const candidateSet = new Set(normalize(candidateGenres));
  
  // Interseção Jaccard: |A ∩ B| / |A|
  const intersection = new Set(
    [...querySet].filter(g => candidateSet.has(g))
  );
  
  return intersection.size / querySet.size;
}

================================================================================

STEP 5: Função para Re-Ranking Híbrido
---------------------------------------

/**
 * Faz re-ranking híbrido dos filmes recomendados.
 * Pontuação Final = (0.7 × Pontuação_BERT) + (0.3 × Pontuação_Gênero)
 */
async function reRankMovies(
  recommendations: MovieRecommendation[],
  queryGenres: string[],
  bertScores?: number[]  // Se a API retornar pontuações BERT
): Promise<ReRankedMovie[]> {
  // Se a API não retornar pontuações BERT, assumimos que todos têm a mesma
  // (ou você pode usar a ordem como proxy: primeiro = maior pontuação)
  const defaultBertScore = 0.75; // Ajuste conforme necessário
  
  const reRanked: ReRankedMovie[] = [];
  
  for (let i = 0; i < recommendations.length; i++) {
    const rec = recommendations[i];
    const bertScore = bertScores?.[i] ?? (defaultBertScore - i * 0.01);
    
    // Calcular pontuação de gênero
    const genreScore = calculateGenreScore(queryGenres, rec.genres_list);
    
    // Calcular pontuação final (média ponderada)
    const finalScore = (0.7 * bertScore) + (0.3 * genreScore);
    
    reRanked.push({
      ...rec,
      bert_score: bertScore,
      genre_score: genreScore,
      final_score: finalScore,
    });
  }
  
  // Ordenar por pontuação final (decrescente)
  reRanked.sort((a, b) => b.final_score - a.final_score);
  
  return reRanked;
}

================================================================================

STEP 6: Função Completa - Fluxo End-to-End
-------------------------------------------

async function getMovieRecommendationsWithReRanking(
  userSelectedMovieId: number
): Promise<ReRankedMovie[]> {
  try {
    // 1. Buscar dados do filme selecionado no TMDB
    console.log('Buscando dados do filme no TMDB...');
    const selectedMovie = await getMovieFromTMDB(userSelectedMovieId);
    
    // Extrair gêneros do filme selecionado (para re-ranking)
    const queryGenres = selectedMovie.genres.map(g => g.name);
    
    // 2. Buscar recomendações na API
    console.log('Buscando recomendações na API...');
    const recommendations = await getRecommendations(
      userSelectedMovieId,
      selectedMovie  // Passar dados para Cold Start se necessário
    );
    
    console.log(`Recebidos ${recommendations.length} filmes da API`);
    
    // 3. Buscar dados completos de todos os filmes recomendados no TMDB
    console.log('Buscando dados completos no TMDB...');
    const moviesWithTMDBData = await Promise.all(
      recommendations.map(async (rec) => {
        try {
          const tmdbData = await getMovieFromTMDB(rec.tmdb_id);
          return { ...rec, tmdb_data: tmdbData };
        } catch (error) {
          console.warn(`Erro ao buscar TMDB data para ${rec.tmdb_id}:`, error);
          return rec; // Continuar sem dados TMDB
        }
      })
    );
    
    // 4. Fazer re-ranking híbrido
    console.log('Fazendo re-ranking híbrido...');
    const reRanked = await reRankMovies(
      moviesWithTMDBData,
      queryGenres
    );
    
    console.log('Re-ranking concluído!');
    return reRanked;
    
  } catch (error) {
    console.error('Erro ao buscar recomendações:', error);
    throw error;
  }
}

================================================================================

STEP 7: Exemplo de Uso em React Component
------------------------------------------

import { useState, useEffect } from 'react';

function MovieRecommendations({ movieId }: { movieId: number }) {
  const [recommendations, setRecommendations] = useState<ReRankedMovie[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    async function loadRecommendations() {
      setLoading(true);
      setError(null);
      
      try {
        const results = await getMovieRecommendationsWithReRanking(movieId);
        setRecommendations(results);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Erro desconhecido');
      } finally {
        setLoading(false);
      }
    }
    
    if (movieId) {
      loadRecommendations();
    }
  }, [movieId]);
  
  if (loading) return <div>Carregando recomendações...</div>;
  if (error) return <div>Erro: {error}</div>;
  
  return (
    <div>
      <h2>Recomendações ({recommendations.length})</h2>
      <div className="movie-grid">
        {recommendations.map((movie) => (
          <div key={movie.tmdb_id} className="movie-card">
            <img
              src={
                movie.poster_path
                  ? `https://image.tmdb.org/t/p/w200${movie.poster_path}`
                  : '/placeholder.jpg'
              }
              alt={movie.title}
            />
            <h3>{movie.title}</h3>
            <p>{movie.year}</p>
            <p>Gêneros: {movie.genres_list.join(', ')}</p>
            <p>Pontuação Final: {movie.final_score.toFixed(3)}</p>
            <p>
              (BERT: {movie.bert_score.toFixed(3)}, 
              Gênero: {movie.genre_score.toFixed(3)})
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}

================================================================================
                        RESUMO DO FLUXO
================================================================================

1. Usuário seleciona filme → Front busca no TMDB
2. Front envia { tmdb_id, top_k: 50 } para API
3. API retorna Top 50 filmes [ { tmdb_id, title, year, poster_path, genres_list }, ... ]
4. Front busca dados completos dos 50 filmes no TMDB (em paralelo)
5. Front calcula pontuação de gênero para cada filme
6. Front calcula pontuação final: (0.7 × BERT) + (0.3 × Gênero)
7. Front ordena por pontuação final
8. Front exibe resultados

================================================================================
                        EXEMPLO DE CÁLCULO
================================================================================

Filme de Busca: "Frankenstein" com gêneros ["Horror", "Drama", "Fantasy"]

Candidato 1: "Big Buck Bunny" com gêneros ["Animation", "Comedy", "Fantasy"]
- Gêneros em comum: 1 (Fantasy)
- Pontuação de Gênero: 1 / 3 = 0.33
- Se BERT = 0.75: Pontuação Final = 0.7 × 0.75 + 0.3 × 0.33 = 0.624

Candidato 2: "O Labirinto do Fauno" com gêneros ["Fantasy", "Drama", "War"]
- Gêneros em comum: 2 (Fantasy, Drama)
- Pontuação de Gênero: 2 / 3 = 0.66
- Se BERT = 0.70: Pontuação Final = 0.7 × 0.70 + 0.3 × 0.66 = 0.688

Resultado: Candidato 2 terá prioridade mesmo com BERT menor!

================================================================================
                        NOTAS IMPORTANTES
================================================================================

1. A API sempre retorna Top 50 (ou o top_k solicitado)
2. O re-ranking é SEMPRE feito no front-end
3. Use os gêneros do filme de busca para calcular a pontuação de gênero
4. A fórmula de re-ranking é: (0.7 × BERT) + (0.3 × Gênero)
5. Warm Start é mais rápido (usa embedding pré-computado)
6. Cold Start é mais lento (gera embedding on-the-fly) mas funciona para filmes novos

================================================================================
                        TRATAMENTO DE ERROS
================================================================================

- Se a API retornar erro 400, pode ser que o filme não esteja no banco
  → Tente novamente com Cold Start (enviando todos os dados)
  
- Se algum filme recomendado não existir mais no TMDB, continue sem ele
  
- Se a busca no TMDB falhar para alguns filmes, continue com os que funcionaram

================================================================================
                        PERFORMANCE
================================================================================

- Busque os 50 filmes no TMDB em paralelo (Promise.all)
- Cache os resultados do TMDB se possível
- Mostre um loading state durante o processo
- Considere fazer paginação se 50 filmes for muito para exibir de uma vez

================================================================================
